	 / _____) _ | |    
	( (____ _____ ____ _| |_ _____ ____| |__  
	 \____ \| ___ | (_ _) ___ |/ ___) _ \
	 _____) ) ____| | | || |_| ____( (___| | | |
	(______/|_____)_|_|_| \__)_____)\____)_| |_|
	  (C)2013 셈텍-싸이클레오

LoRa 집중기 HAL 사용 설명서
=============================

1. 소개
---------------

LoRa 집중 장치 하드웨어 추상화 계층은 다음을 허용하는 C 라이브러리입니다.
높은 수준의 C의 감소된 수를 통해 Semtech 집광기 칩을 사용
하드웨어를 구성하고 패킷을 보내고 받는 기능.

Semtech LoRa 집중 장치는 디지털 다중 채널 다중 표준 패킷입니다.
LoRa 또는 FSK 변조를 사용하여 무선으로 패킷을 보내고 받는 데 사용되는 라디오.

2. 라이브러리의 구성요소
--------------------------

라이브러리는 6개의 모듈로 구성됩니다.

* 로라그_할
* loragw_reg
* loragw_mcu
* loragw_com
* loragw_aux
* loragw_radio

라이브러리에는 코드 사용 및 검사를 보여주기 위한 기본 테스트 프로그램도 포함되어 있습니다.
기능.

### 2.1. loragw_hal ###

이것은 메인 모듈이며 구성 및 구성하는 고급 기능을 포함합니다.
LoRa 집중 장치 사용:

* lgw_board_setconf, 집중 장치의 구성을 설정합니다.
* lgw_rxrf_setconf, 라디오 채널 구성 설정
* lgw_rxif_setconf, IF+모뎀 채널 구성 설정
* lgw_txgain_setconf, 집중기 이득 테이블의 구성을 설정합니다.
* lgw_start, 설정된 구성을 하드웨어에 적용하고 시작
* lgw_stop, 하드웨어 정지
* lgw_receive, 수신된 패킷이 있는 경우 가져오기
* lgw_send, 단일 패킷 전송(비차단, 사용 섹션의 경고 참조)
* lgw_status, 패킷이 효과적으로 전송되었는지 확인하기 위해

표준 애플리케이션의 경우 이 모듈만 포함합니다.
이 모듈의 사용은 사용 섹션에 자세히 설명되어 있습니다.

/!\ 패킷을 보낼 때 아날로그 회로에 1.5ms 지연이 있습니다.
시작하고 안정적입니다(TX_START_DELAY).

'타임스탬프' 모드에서 이것은 투명합니다. 모뎀은 1.5ms 전에 시작됩니다.
사용자가 설정한 타임스탬프 값에 도달하면 패킷의 프리앰블이 다음과 같이 시작됩니다.
내부 타임스탬프 카운터가 목표 값에 도달했습니다.

'즉시' 모드에서 패킷은 가능한 한 빨리 방출됩니다.
호스트에서 집선기로 가는 패킷(및 해당 매개변수)은 시간이 걸립니다.
TX_START_DELAY가 있으면 패킷이 방출됩니다.

'트리거' 모드(PPS/GPS 모드라고도 함)에서 패킷(일반적으로 비컨)은 다음과 같습니다.
트리거 신호의 상승 에지 후 1.5ms가 방출됩니다. 없기 때문에
트리거링 이벤트를 예상하고 아날로그 회로를 시작하는 방법
사전에 프로토콜에서 해당 지연을 고려해야 합니다.

### 2.2. loragw_mcu ###

이 모듈은 HAL 기능을 집중 장치로 보낼 명령으로 래핑합니다.
MCU.

HAL 구조는 바이트 배열로 직렬화되어 COM/USB를 통해 전송됩니다.
상호 작용.

* 보드 구성
* 패킷 보내기/받기
* ...

### 2.3. loragw_reg ###

이 모듈은 대신 이름으로 LoRa 집중기 레지스터에 액세스하는 데 사용됩니다.
주소별:

* lgw_connect, 초기화 및 하드웨어 연결 확인
* lgw_disconnect, 하드웨어 연결 해제
* lgw_soft_reset, 레지스터 배열을 재설정하여 전체 하드웨어를 재설정합니다.
* lgw_reg_check, 모든 레지스터와 기본값을 확인하고 출력
결과를 파일로
* lgw_reg_r, 명명된 레지스터 읽기
* lgw_reg_w, 명명된 레지스터 쓰기
* lgw_reg_rb, 버스트에서 이름 레지스터 읽기
* lgw_reg_wb, 버스트에 명명된 레지스터 쓰기

이 모듈은 페이지 매김, 읽기 전용 레지스터 보호, 멀티바이트를 처리합니다.
레지스터 관리, 서명된 레지스터 관리, 읽기-수정-쓰기 루틴
SPI를 준수하기 위한 서브바이트 레지스터 및 읽기/쓰기 버스트 조각화용
최대 버스트 길이 제약

코드를 읽고 디버그하기가 훨씬 쉽습니다.
또한 레지스터가 다른 하드웨어 버전 간에 재배치되지만
동일한 기능을 유지하면 레지스터 이름을 사용하여 작성된 코드를 "다음과 같이" 재사용할 수 있습니다.
이다".

모든 레지스터에 액세스해야 하는 경우 이 모듈을
애플리케이션.

**/!\ 경고** LoRa를 잘 이해하시기 바랍니다.
내부 레지스터에 직접 액세스하기 전에 집중기 내부 작업.

### 2.4. loragw_com ###

이 모듈에는 LoRa 집중기 레지스터에 액세스하는 기능이 포함되어 있습니다.
USB/UART 인터페이스를 통한 어레이:

* lgw_com_r은 1바이트를 읽습니다.
* lgw_com_w 1바이트 쓰기
* lgw_com_rb는 2바이트 이상을 읽습니다.
* lgw_com_wb는 2바이트 이상 쓰기

해당 모듈을 애플리케이션에 직접 포함하지 *마세요*.

**/!\ 경고** 없이 LoRa 집중기 레지스터 어레이에 액세스
loragw_reg의 기능에서 제공하는 검사 및 안전은 권장되지 않습니다.

### 2.5. loragw_aux ###

이 모듈에는 잠시 동안 일시 중지하는 단일 호스트 종속 함수 wait_ms가 포함되어 있습니다.
밀리초 단위로 정의됩니다.

에 포함된 LoRa 집중기 하드웨어를 시작하고 구성하는 절차
loragw_hal 모듈은 특정 시간에 몇 밀리초를 기다려야 합니다.
일반적으로 공급 전압 또는 클록이 안정화된 후
켰다.

1ms 이하의 정확도가 이상적입니다.
시스템에서 해당 수준의 정확도를 허용하지 않는 경우 실제
지연은 함수가 호출될 때 지정된 시간(즉,
wait_ms(X) **어떤 상황에서도 X 밀리초 이전에 **해서는 안 됩니다**.

구성 및 시작 중에 최소 지연이 보장되지 않는 경우
절차에 따라 하드웨어가 정상 성능으로 작동하지 않을 수 있습니다.
대부분의 경우 전혀 작동하지 않습니다.

### 2.6. loragw_radio ###

이 모듈에는 SX125x 라디오 구성을 처리하는 기능이 포함되어 있습니다.


3. 소프트웨어 빌드 프로세스
--------------------------

### 3.1. 소프트웨어 세부 정보 ###

라이브러리는 ANSI C 규칙에 따라 작성되었지만 명시적 C99를 사용합니다.
하드웨어 및 매개변수와의 모든 데이터 교환을 위한 길이 데이터 유형.

loragw_aux 모듈에는 밀리초에 대한 POSIX 종속 함수가 포함되어 있습니다.
정확도 일시 중지.
임베디드 플랫폼의 경우 하드웨어 타이머를 사용하여 함수를 다시 작성할 수 있습니다.

### 3.2. 건물 옵션 ###

모든 모듈은 fprintf(stderr,...) 함수를 사용하여 디버그 진단을 표시합니다.
library.cfg에서 DEBUG_xxx가 1로 설정된 경우 메시지

### 3.3. 구축 절차 ###

교차 컴파일을 위해 Makefile에서 ARCH 및 CROSS_COMPILE 변수를 설정합니다.
또는 셸 환경에서 올바른 도구 모음 이름과 경로를 사용합니다.
전:
내보내기 경로=/home/foo/rpi-toolchain/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin:$PATH
내보내기 ARCH=암
내보내기 CROSS_COMPILE=arm-linux-gnueabihf-

libloragw 디렉토리의 Makefile은 library.cfg 파일을 구문 분석하고
#define 옵션이 포함된 config.h C 헤더 파일을 생성합니다.
이러한 옵션은 loragw_xxx.h 파일의 코드 섹션을 활성화 및 비활성화합니다.
및 *.c 소스 파일.

library.cfg는 또한 적절한 동적 집합을 선택하는 데 직접 사용됩니다.
연결할 라이브러리.

### 3.4. 내 보내다 ###

빌드 후 다른 시스템에서 해당 라이브러리를 사용하려면 다음을 내보내야 합니다.
다음 파일:

* libloragw/library.cfg -> 루트 구성 파일
* libloragw/libloragw.a -> 정적 라이브러리, 프로그램과 연결
* libloragw/readme.md -> 라이선스 준수에 필요
* libloragw/inc/config.h -> library.cfg에서 파생된 C 구성 플래그
* libloragw/inc/loragw_*.h -> 필요한 것만 가져옵니다(예: _hal 및 _gps)

라이브러리를 애플리케이션에 정적으로 링크한 후 라이선스만
프로그램 문서 내에서 보관하거나 복사해야 합니다.

4. 하드웨어 종속성
------------------------

### 4.1. 하드웨어 개정 ###

loragw_reg 및 loragw_hal은 Semtech의 특정 버전용으로 작성되었습니다.
하드웨어(IP 및/또는 실리콘 개정판).

이 코드는 다음을 위해 작성되었습니다.

* 셈텍 SX1301 칩
* Semtech SX1257 또는 SX1255 I/Q 트랜시버

하드웨어 버전이 일치하지 않으면 라이브러리가 작동하지 않습니다.
그리고 라이브러리 버전. 테스트 프로그램 test_loragw_reg를 사용하여 확인할 수 있습니다.
하드웨어 레지스터가 소프트웨어 선언과 일치하는 경우.

### 4.2. USB/UART 통신 ###

loragw_com에는 4가지 기능(읽기, 쓰기, 버스트 읽기, 버스트 쓰기)이 포함되어 있습니다.
플랫폼에 따라 다릅니다.
사용하는 통신 브리지에 따라 기능을 다시 작성해야 합니다.

* Linux tty 포트를 통한 USB/UART(제공됨)

테스트 프로그램 test_loragw_com을 사용하여 USB 통신이
작동 중입니다.


5. 사용법
--------

### 5.1. 소프트웨어 환경 설정 ###

일반적인 애플리케이션의 경우 다음을 수행해야 합니다.

* 프로그램 소스에 loragw_hal.h 포함
* 컴파일 중 libloragw.a 정적 라이브러리에 대한 링크
* loragw_aux 종속성(타이밍 함수)으로 인한 librt 라이브러리 링크

집중 장치 구성에도 액세스하는 애플리케이션의 경우
직접 등록(예: 고급 구성의 경우) 또한 다음을 수행해야 합니다.

* 프로그램 소스에 loragw_reg.h 포함

### 5.2. 소프트웨어 API 사용 ###

애플리케이션에서 HAL을 사용하려면 몇 가지 기본 규칙을 따라야 합니다.

* 라디오를 시작하기 전에 라디오 경로와 IF+모뎀 경로를 구성하십시오.
* 구성은 *start*를 호출할 때만 하드웨어로 전송됩니다.
  함수
* 하나(또는 +) 라디오가 활성화되고 하나(또는 +)가 활성화될 때까지 패킷을 수신할 수 없습니다.
  IF+모뎀 부분이 활성화되고 집중 장치가 시작됨
* 하나(또는 +) 라디오가 활성화되고 집중 장치가 활성화될 때까지 패킷을 보낼 수 없습니다.
  시작된다
* 구성을 변경하기 전에 집중기를 중지해야 합니다.

HAL을 사용하기 위한 일반적인 애플리케이션 흐름은 다음과 같습니다.

	<라디오 및 IF+모뎀 구성>
	<LoRa 집중 장치 시작>
	루프 {
		<집선기에서 수신한 패킷 가져오기>
		<수신된 패킷 처리, 저장 및/또는 전달>
		<집선기를 통해 패킷 보내기>
	}
	<집중기 정지>

**/!\ 경고** lgw_send 함수는 차단되지 않으며 반환되는 동안
LoRa 집선기는 여전히 패킷을 전송 중이거나 패킷이 전송되기 전에
패킷이 미래 이벤트에서 트리거되면 전송되기 시작했습니다.
패킷이 방출되는 동안에는 패킷을 수신할 수 없습니다.
대부분의 무선 주파수 시스템).

귀하의 신청서는 *반드시* 패킷을 보내는 데 걸리는 시간을 고려해야 합니다.
다른 패킷을 보내기 전에 상태를 확인하십시오(lgw_status 사용).

이전 패킷 전송이 완료되지 않은 상태에서 패킷 전송 시도
이전 패킷이 전송되지 않거나 부분적으로만 전송됩니다.
(수신기에서 CRC 오류가 발생함).

### 5.3. 디버깅 모드 ###

애플리케이션을 디버그하려면 loragw_hal 함수를 컴파일하는 것이 도움이 될 수 있습니다.
디버그 메시지가 활성화된 경우(library.cfg에서 DEBUG_HAL=1로 설정).
그런 다음 자세한 오류 메시지를 포함하여 많은 세부 정보를 *stderr*로 보냅니다.

6. 라이선스
-----------

Copyright (c) 2013, SEMTECH SA
판권 소유.

소스 및 바이너리 형식의 재배포 및 사용(포함 여부에 관계 없음)
다음 조건이 충족되는 경우 수정이 허용됩니다.

* 소스 코드의 재배포는 위의 저작권을 보유해야 합니다.
  통지, 이 조건 목록 및 다음 부인.
* 바이너리 형태의 재배포는 위의 저작권을 복제해야 함
  통지, 이 조건 목록 및 다음 면책 조항
  배포와 함께 제공된 문서 및/또는 기타 자료.
* (주)셈텍 법인명 또는 법인명 아님
  기여자의 이름은 제품을 보증하거나 홍보하는 데 사용될 수 있습니다.
  특정 사전 서면 허가 없이 이 소프트웨어에서 파생된 것입니다.

이 소프트웨어는 저작권 보유자와 기여자가 "있는 그대로" 제공하며
묵시적 보증을 포함하되 이에 국한되지 않는 모든 명시적 또는 묵시적 보증
상품성 및 특정 목적에의 적합성에 대한 보증은 다음과 같습니다.
부인. SEMTECH SA는 어떠한 경우에도 책임을 지지 않습니다.
직접적, 간접적, 부수적, 특수적, 예시적 또는 결과적 손해
(대체 상품 또는 서비스 조달을 포함하되 이에 국한되지 않음,
사용, 데이터 또는 이익의 손실 또는 업무 중단)
계약, 엄격한 책임 또는 불법 행위 여부에 관계없이 모든 책임 이론에 대해
(과실 또는 기타 포함) 이 사용으로 인해 발생하는
그러한 손상의 가능성에 대해 통지를 받은 경우에도 소프트웨어.

*EOF*